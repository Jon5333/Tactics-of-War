<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Napoleon Battle Game</title>
<style>
  body { font-family: Arial, sans-serif; background: #f4f4f4; }
  #startScreen, #gameUI { text-align: center; padding: 20px; }
  #battlefield {
    display: grid;
    grid-template-columns: repeat(20, 60px);
    grid-gap: 3px;
    justify-content: center;
    margin: 20px auto;
    background-color: #333;
    padding: 10px;
    border-radius: 10px;
  }
  .tile {
    width: 60px; height: 60px;
    border: 1px solid #999;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    font-size: 14px; cursor: pointer; text-align: center;
    border-radius: 5px;
    color: black; font-weight: bold;
    position: relative;
    transition: background-color 0.3s;
  }
  .tile.routed {
    background-color: #ffcccc !important; /* red tint for routed units */
  }
  .unit-label { font-size: 16px; }
  .hp-bar, .morale-bar { font-size: 12px; color: #111; }
  .plain { background: #d8d8d8; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(0deg,transparent 75%,#bbb 75%),linear-gradient(90deg,transparent 75%,#bbb 75%); }
  .hill { background: #c4b087; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(45deg,#b59e70 25%,transparent 25%),linear-gradient(-45deg,#b59e70 25%,transparent 25%); }
  .forest { background: #5a8f5a; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(0deg,transparent 75%,#4d7a4d 75%),linear-gradient(90deg,transparent 75%,#4d7a4d 75%); }
  .river { background: #5daee6; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(135deg,#72c2f1 25%,transparent 25%),linear-gradient(45deg,#72c2f1 25%,transparent 25%); }
  .bridge { background: #997950; background-size:6px 6px; image-rendering:pixelated;
    background-image: repeating-linear-gradient(0deg,#a88a64,#a88a64 5px,#8c6b3d 5px,#8c6b3d 10px); }
  .selected { outline: 3px solid red; }
  .tile.france { color: blue; }
  .tile.russia { color: darkred; }

  /* Animations for visual effects */
  @keyframes attackFlash {
    0% { background-color: #fff0f0; }
    50% { background-color: #ff0000; }
    100% { background-color: initial; }
  }
  @keyframes moralePulse {
    0%, 100% { box-shadow: none; }
    50% { box-shadow: 0 0 8px 3px rgba(255, 0, 0, 0.7); }
  }
  .tile.attack-hit {
    animation: attackFlash 0.5s ease forwards;
  }
  .tile.morale-break {
    animation: moralePulse 1s ease infinite;
  }
</style>
</head>
<body>

<div id="startScreen">
  <h1>Napoleon Battle Game</h1>
  <div>
    Faction: <span id="deployFaction">France</span><br/>
    <label>
      Unit Type:
      <select id="unitType">
        <option value="infantry">Infantry</option>
        <option value="cavalry">Cavalry</option>
        <option value="artillery">Artillery</option>
      </select>
    </label>
    <br/><br/>
    <button id="deployBtn">Deploy/Next</button>
  </div>
</div>

<div id="gameUI">
  <h3 id="turnDisplay" style="display:none;">Turn: France</h3>
  <button id="endTurnBtn" style="display:none;">End Turn</button>
  <div id="battlefield"></div>
</div>

<!-- Sound effects -->
<audio id="moveSound" src="https://actions.google.com/sounds/v1/footsteps/footsteps_grass.ogg" preload="auto"></audio>
<audio id="attackSound" src="https://actions.google.com/sounds/v1/impacts/wood_thud.ogg" preload="auto"></audio>
<audio id="routingSound" src="https://actions.google.com/sounds/v1/alarms/warning_1.ogg" preload="auto"></audio>

<script>
let grid = [];
let selectedUnitType = 'infantry';
let currentFaction = 'france';
let deploymentPhase = true;
let selectedTile = null;
let audioUnlocked = false;

function unlockAudio() {
  if (audioUnlocked) return;
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillator = ctx.createOscillator();
  oscillator.connect(ctx.destination);
  oscillator.start();
  oscillator.stop(ctx.currentTime + 0.01);
  audioUnlocked = true;
}

function playSound(id) {
  const snd = document.getElementById(id);
  if (snd) {
    snd.currentTime = 0;
    snd.play().catch(e => {
      // console.log('Sound play prevented:', e);
    });
  }
}

document.getElementById('unitType').onchange = e => {
  selectedUnitType = e.target.value;
};

document.getElementById('deployBtn').onclick = () => {
  unlockAudio();
  if (currentFaction === 'france') {
    currentFaction = 'russia';
    document.getElementById('deployFaction').textContent = 'Russia';
  } else {
    deploymentPhase = false;
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('turnDisplay').style.display = 'block';
    document.getElementById('endTurnBtn').style.display = 'inline-block';
    document.getElementById('turnDisplay').textContent = 'Turn: France';
    currentFaction = 'france';
  }
};

document.getElementById('endTurnBtn').onclick = endTurn;

function createBattlefield(rows = 20, cols = 20) {
  const container = document.getElementById('battlefield');
  container.innerHTML = '';
  grid = [];

  const terrainTypes = ['plain', 'hill', 'forest'];
  const map = Array(rows).fill().map(() => Array(cols).fill('plain'));

  for (let i = 0; i < 100; i++) {
    const r = Math.floor(Math.random() * rows);
    const c = Math.floor(Math.random() * cols);
    const type = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
    map[r][c] = type;
  }

  for (let r = 0; r < rows; r++) {
    const mid = Math.floor(cols / 2);
    map[r][mid] = 'river';
    if (Math.random() > 0.7 && mid + 1 < cols) map[r][mid + 1] = 'river';
  }

  map[2][10] = 'bridge';
  map[17][10] = 'bridge';

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const tile = document.createElement('div');
      const type = map[r][c];
      tile.className = `tile ${type}`;
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.dataset.terrain = type;
      tile.onclick = handleTileClick;
      container.appendChild(tile);
      grid.push({ row: r, col: c, terrain: type, unit: null, element: tile });
    }
  }
}

function updateTileDisplay(tileData) {
  const tile = tileData.element;
  tile.innerHTML = '';
  tile.classList.remove('france', 'russia', 'routed', 'selected', 'morale-break', 'attack-hit');

  if (tileData.unit) {
    const unit = tileData.unit;
    tile.classList.add(unit.faction);
    if (unit.routing) tile.classList.add('routed');

    // Add morale-break effect if routing
    if (unit.routing) tile.classList.add('morale-break');

    const label = document.createElement('div');
    label.className = 'unit-label';
    label.textContent = unit.routing ? 'R' : unit.type[0].toUpperCase();

    const hp = document.createElement('div');
    hp.className = 'hp-bar';
    hp.textContent = `${unit.hp} HP`;

    const morale = document.createElement('div');
    morale.className = 'morale-bar';
    morale.textContent = `Morale: ${unit.morale}`;

    tile.appendChild(label);
    tile.appendChild(hp);
    tile.appendChild(morale);
  }
}

function getCombatModifier(terrain) {
  if (terrain === 'forest') return 0.9;
  if (terrain === 'hill') return 1.1;
  if (terrain === 'river') return 0.8;
  return 1.0;
}

function handleTileClick(e) {
  const tile = e.currentTarget;
  const row = +tile.dataset.row;
  const col = +tile.dataset.col;
  const tileData = grid.find(t => t.row === row && t.col === col);

  if (deploymentPhase) {
    if ((currentFaction === 'france' && row >= 10) || (currentFaction === 'russia' && row < 10)) return;
    if (tileData.unit) return;

    const unit = {
      type: selectedUnitType,
      faction: currentFaction,
      hp: 100,
      morale: 100,
      hasMoved: false,
      hasAttacked: false,
      routing: false,
      routingTurns: 0
    };

    tileData.unit = unit;
    updateTileDisplay(tileData);
    playSound('moveSound');
    return;
  }

  if (!deploymentPhase) {
    if (selectedTile) {
      selectedTile.classList.remove('selected');
    }

    const tileUnit = tileData.unit;

    if (selectedTile === tile) {
      // Deselect if clicking same tile
      selectedTile = null;
      return;
    }

    if (!selectedTile) {
      // Select unit if it belongs to current faction and is not routed and can move
      if (tileUnit && tileUnit.faction === currentFaction && !tileUnit.routing && !tileUnit.hasMoved) {
        tile.classList.add('selected');
        selectedTile = tile;
      }
      return;
    }

    // If a unit is selected, try move or attack
    const fromRow = +selectedTile.dataset.row;
    const fromCol = +selectedTile.dataset.col;
    const fromTileData = grid.find(t => t.row === fromRow && t.col === fromCol);
    const fromUnit = fromTileData.unit;

    const dx = Math.abs(fromRow - row);
    const dy = Math.abs(fromCol - col);
    const isAdjacent = dx + dy === 1;

    if (isAdjacent && fromUnit && fromUnit.faction === currentFaction && !fromUnit.hasMoved && !fromUnit.routing) {
      if (!tileUnit) {
        // Move
        tileData.unit = fromUnit;
        tileData.unit.hasMoved = true;
        updateTileDisplay(tileData);
        fromTileData.unit = null;
        updateTileDisplay(fromTileData);
        playSound('moveSound');
      } else if (tileUnit.faction !== currentFaction && !fromUnit.hasAttacked) {
        // Attack
        const attackerMod = getCombatModifier(fromTileData.terrain);
        const damage = Math.floor(30 * attackerMod);
        tileUnit.hp -= damage;
        tileUnit.morale -= 25;
        fromUnit.hasAttacked = true;
        playSound('attackSound');

        // Flash attacked tile
        tile.classList.add('attack-hit');
        setTimeout(() => tile.classList.remove('attack-hit'), 500);

        if (tileUnit.morale <= 30 && !tileUnit.routing) {
          tileUnit.routing = true;
          tileUnit.routingTurns = 0;
          playSound('routingSound');
          tile.classList.add('morale-break');
        }
        if (tileUnit.hp <= 0 || tileUnit.morale <= 0) {
          tileData.unit = null;
let grid = [];
let currentFaction = 'france';
let selectedUnitType = 'infantry';
let deploymentPhase = true;
let selectedTile = null;

const combatMods = {
  plain: 1,
  hill: 1.1,
  forest: 0.9,
  river: 0.8,
  bridge: 1
};

const generals = {
  france: [
    { name: "Napoleon", bonus: 0.25 },
    { name: "Murat", bonus: 0.1 }
  ],
  russia: [
    { name: "Kutuzov", bonus: 0.2 },
    { name: "Bagration", bonus: 0.15 }
  ]
};

let selectedGeneral = {
  france: null,
  russia: null
};

document.getElementById('unitType').onchange = e => {
  selectedUnitType = e.target.value;
};

document.getElementById('deployBtn').onclick = deployNext;
document.getElementById('endTurnBtn').onclick = endTurn;

function setupGeneralDropdown() {
  const sel = document.getElementById('generalSelector');
  sel.innerHTML = '';
  generals[currentFaction].forEach((g, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = g.name;
    sel.appendChild(opt);
  });
}

function deployNext() {
  const genIdx = document.getElementById('generalSelector').value;
  selectedGeneral[currentFaction] = generals[currentFaction][genIdx];

  if (currentFaction === 'france') {
    currentFaction = 'russia';
    document.getElementById('deployFaction').textContent = 'Russia';
    setupGeneralDropdown();
  } else {
    deploymentPhase = false;
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameUI').style.display = 'block';
    updateTurnDisplay();
  }
}

function updateTurnDisplay() {
  document.getElementById('turnDisplay').textContent =
    'Current Turn: ' + (currentFaction === 'france' ? 'France' : 'Russia');
}

function createBattlefield() {
  const bf = document.getElementById('battlefield');
  bf.innerHTML = '';
  grid = [];

  const rows = 20, cols = 20;
  let map = Array(rows).fill().map(() => Array(cols).fill('plain'));

  for (let i = 0; i < 50; i++) {
    let r = Math.floor(Math.random() * rows),
      c = Math.floor(Math.random() * cols),
      t = Math.random() < 0.5 ? 'forest' : 'hill';
    map[r][c] = t;
  }

  const mid = Math.floor(cols / 2);
  for (let r = 0; r < rows; r++) {
    map[r][mid] = 'river';
    if (Math.random() > 0.7 && mid + 1 < cols) map[r][mid + 1] = 'river';
  }

  map[2][mid] = 'bridge';
  map[17][mid] = 'bridge';

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const terrain = map[r][c];
      const div = document.createElement('div');
      div.className = `tile ${terrain}`;
      div.dataset.row = r;
      div.dataset.col = c;
      div.dataset.terrain = terrain;
      div.onclick = () => onTileClick(r, c);
      bf.appendChild(div);
      grid.push({ row: r, col: c, terrain, unit: null, element: div });
    }
  }

  setupGeneralDropdown();
}

function onTileClick(r, c) {
  const cell = grid.find(t => t.row === r && t.col === c);

  if (deploymentPhase) {
    if ((currentFaction === 'france' && r >= 10) ||
      (currentFaction === 'russia' && r < 10)) return;
    if (cell.unit) return;

    let unit = {
      type: selectedUnitType,
      faction: currentFaction,
      hp: 100,
      morale: 100,
      hasMoved: false,
      hasAttacked: false,
      routed: false,
      routeTurns: 0
    };

    if (selectedUnitType === 'infantry') {
      unit.morale += selectedGeneral[currentFaction].bonus * 100;
    }

    // Allow only one general to be deployed
    if (selectedUnitType === 'general') {
      if (grid.some(t => t.unit && t.unit.faction === currentFaction && t.unit.type === 'general')) return;
      unit.hp = 150;
      unit.morale = 150;
      unit.type = 'general';
      unit.isGeneral = true;
    }

    cell.unit = unit;
    renderCell(cell);
    return;
  }

  if (!selectedTile) {
    if (cell.unit &&
      cell.unit.faction === currentFaction &&
      !cell.unit.hasMoved &&
      !cell.unit.routed) {
      selectedTile = cell;
      cell.element.classList.add('selected');
    }
  } else {
    selectedTile.element.classList.remove('selected');
    attemptAction(selectedTile, cell);
    selectedTile = null;
  }
}

function attemptAction(from, to) {
  const unit = from.unit;
  const dist = Math.abs(from.row - to.row) + Math.abs(from.col - to.col);
  if (dist !== 1 || unit.hasMoved) return;

  if (!to.unit) {
    to.unit = unit;
    from.unit = null;
    unit.hasMoved = true;
    renderCell(from);
    renderCell(to);
  } else if (to.unit.faction !== currentFaction && !unit.hasAttacked) {
    let baseAttack = 30;
    const attack = baseAttack * combatMods[from.terrain];
    to.unit.hp -= attack;
    to.unit.morale -= 25;
    unit.hasAttacked = true;

    // Nearby general morale boost
    const nearbyGeneral = grid.find(t =>
      t.unit && t.unit.type === 'general' &&
      t.unit.faction === unit.faction &&
      Math.abs(t.row - from.row) + Math.abs(t.col - from.col) <= 2
    );
    if (nearbyGeneral) {
      unit.morale += 5;
    }

    if (to.unit.morale <= 30 && !to.unit.routed) {
      to.unit.routed = true;
      to.element.classList.add('routed');
    }

    // If general dies, morale penalty to faction
    if (to.unit.hp <= 0 || to.unit.morale <= 0) {
      if (to.unit.type === 'general') {
        grid.forEach(cell => {
          if (cell.unit && cell.unit.faction === to.unit.faction) {
            cell.unit.morale -= 25;
          }
        });
      }
      to.unit = null;
    }

    renderCell(from);
    renderCell(to);
    checkWinCondition();
  }
}

function renderCell(cell) {
  const el = cell.element;
  el.className = `tile ${cell.terrain}`;
  el.textContent = '';
  if (cell.unit) {
    el.classList.add(cell.unit.faction);
    if (cell.unit.routed) el.classList.add('routed');

    const lbl = document.createElement('div');
    lbl.textContent = cell.unit.type[0].toUpperCase();
    lbl.className = 'unit-label';

    const hp = document.createElement('div');
    hp.textContent = `${Math.round(cell.unit.hp)} HP`;
    hp.className = 'hp-bar';

    const mr = document.createElement('div');
    mr.textContent = `${Math.round(cell.unit.morale)} M`;
    mr.className = 'morale-bar';

    el.append(lbl, hp, mr);
  }
}

function endTurn() {
  grid.forEach(cell => {
    if (cell.unit && cell.unit.faction === currentFaction) {
      cell.unit.hasMoved = false;
      cell.unit.hasAttacked = false;
      if (cell.unit.routed) {
        cell.unit.routeTurns++;
        moveRouted(cell);
        if (cell.unit.routeTurns > 3) {
          cell.unit = null;
        }
      }
    }
    renderCell(cell);
  });

  currentFaction = currentFaction === 'france' ? 'russia' : 'france';
  updateTurnDisplay();
  checkWinCondition();
}

function moveRouted(cell) {
  const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
  for (let [dr, dc] of dirs) {
    const nr = cell.row + dr, nc = cell.col + dc;
    const nxt = grid.find(t => t.row === nr && t.col === nc);
    if (nxt && !nxt.unit) {
      nxt.unit = cell.unit;
      nxt.element.classList.add('routed');
      nxt.unit.hasMoved = true;
      cell.unit = null;
      renderCell(nxt);
      renderCell(cell);
      break;
    }
  }
}

function checkWinCondition() {
  const franceAlive = grid.some(t => t.unit && t.unit.faction === 'france' && !t.unit.routed);
  const russiaAlive = grid.some(t => t.unit && t.unit.faction === 'russia' && !t.unit.routed);
  if (!franceAlive) { alert('Russia Wins!'); resetGame(); }
  if (!russiaAlive) { alert('France Wins!'); resetGame(); }
}

function resetGame() {
  deploymentPhase = true;
  grid = [];
  currentFaction = 'france';
  document.getElementById('startScreen').style.display = 'block';
  document.getElementById('gameUI').style.display = 'none';
  document.getElementById('deployFaction').textContent = 'France';
  createBattlefield();
}

createBattlefield();
</script>

</body>
</html>
