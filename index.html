<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Napoleon Battle Game</title>
<style>
  body { font-family: Arial, sans-serif; background: #f4f4f4; }
  #startScreen, #gameUI { text-align: center; padding: 20px; }
  #battlefield {
    display: grid;
    grid-template-columns: repeat(20, 60px);
    grid-gap: 3px;
    justify-content: center;
    margin: 20px auto;
    background-color: #333;
    padding: 10px;
    border-radius: 10px;
  }
  .tile {
    width: 60px; height: 60px;
    border: 1px solid #999;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    font-size: 14px; cursor: pointer; text-align: center;
    border-radius: 5px;
    color: black; font-weight: bold;
    position: relative;
    transition: background-color 0.3s;
  }
  .tile.routed {
    background-color: #ffcccc !important; /* red tint for routed units */
  }
  .unit-label { font-size: 16px; }
  .hp-bar, .morale-bar { font-size: 12px; color: #111; }
  .plain { background: #d8d8d8; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(0deg,transparent 75%,#bbb 75%),linear-gradient(90deg,transparent 75%,#bbb 75%); }
  .hill { background: #c4b087; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(45deg,#b59e70 25%,transparent 25%),linear-gradient(-45deg,#b59e70 25%,transparent 25%); }
  .forest { background: #5a8f5a; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(0deg,transparent 75%,#4d7a4d 75%),linear-gradient(90deg,transparent 75%,#4d7a4d 75%); }
  .river { background: #5daee6; background-size:6px 6px; image-rendering:pixelated;
    background-image: linear-gradient(135deg,#72c2f1 25%,transparent 25%),linear-gradient(45deg,#72c2f1 25%,transparent 25%); }
  .bridge { background: #997950; background-size:6px 6px; image-rendering:pixelated;
    background-image: repeating-linear-gradient(0deg,#a88a64,#a88a64 5px,#8c6b3d 5px,#8c6b3d 10px); }
  .selected { outline: 3px solid red; }
  .tile.france { color: blue; }
  .tile.russia { color: darkred; }

  /* Animations for visual effects */
  @keyframes attackFlash {
    0% { background-color: #fff0f0; }
    50% { background-color: #ff0000; }
    100% { background-color: initial; }
  }
  @keyframes moralePulse {
    0%, 100% { box-shadow: none; }
    50% { box-shadow: 0 0 8px 3px rgba(255, 0, 0, 0.7); }
  }
  .tile.attack-hit {
    animation: attackFlash 0.5s ease forwards;
  }
  .tile.morale-break {
    animation: moralePulse 1s ease infinite;
  }
</style>
</head>
<body>

<div id="startScreen">
  <h1>Napoleon Battle Game</h1>
  <div>
    Faction: <span id="deployFaction">France</span><br/>
    <label>
      Unit Type:
      <select id="unitType">
        <option value="infantry">Infantry</option>
        <option value="cavalry">Cavalry</option>
        <option value="artillery">Artillery</option>
      </select>
    </label>
    <br/><br/>
    <button id="deployBtn">Deploy/Next</button>
  </div>
</div>

<div id="gameUI">
  <h3 id="turnDisplay" style="display:none;">Turn: France</h3>
  <button id="endTurnBtn" style="display:none;">End Turn</button>
  <div id="battlefield"></div>
</div>

<!-- Sound effects -->
<audio id="moveSound" src="https://actions.google.com/sounds/v1/footsteps/footsteps_grass.ogg" preload="auto"></audio>
<audio id="attackSound" src="https://actions.google.com/sounds/v1/impacts/wood_thud.ogg" preload="auto"></audio>
<audio id="routingSound" src="https://actions.google.com/sounds/v1/alarms/warning_1.ogg" preload="auto"></audio>

<script>
let grid = [];
let selectedUnitType = 'infantry';
let currentFaction = 'france';
let deploymentPhase = true;
let selectedTile = null;
let audioUnlocked = false;

function unlockAudio() {
  if (audioUnlocked) return;
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillator = ctx.createOscillator();
  oscillator.connect(ctx.destination);
  oscillator.start();
  oscillator.stop(ctx.currentTime + 0.01);
  audioUnlocked = true;
}

function playSound(id) {
  const snd = document.getElementById(id);
  if (snd) {
    snd.currentTime = 0;
    snd.play().catch(e => {
      // console.log('Sound play prevented:', e);
    });
  }
}

document.getElementById('unitType').onchange = e => {
  selectedUnitType = e.target.value;
};

document.getElementById('deployBtn').onclick = () => {
  unlockAudio();
  if (currentFaction === 'france') {
    currentFaction = 'russia';
    document.getElementById('deployFaction').textContent = 'Russia';
  } else {
    deploymentPhase = false;
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('turnDisplay').style.display = 'block';
    document.getElementById('endTurnBtn').style.display = 'inline-block';
    document.getElementById('turnDisplay').textContent = 'Turn: France';
    currentFaction = 'france';
  }
};

document.getElementById('endTurnBtn').onclick = endTurn;

function createBattlefield(rows = 20, cols = 20) {
  const container = document.getElementById('battlefield');
  container.innerHTML = '';
  grid = [];

  const terrainTypes = ['plain', 'hill', 'forest'];
  const map = Array(rows).fill().map(() => Array(cols).fill('plain'));

  for (let i = 0; i < 100; i++) {
    const r = Math.floor(Math.random() * rows);
    const c = Math.floor(Math.random() * cols);
    const type = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
    map[r][c] = type;
  }

  for (let r = 0; r < rows; r++) {
    const mid = Math.floor(cols / 2);
    map[r][mid] = 'river';
    if (Math.random() > 0.7 && mid + 1 < cols) map[r][mid + 1] = 'river';
  }

  map[2][10] = 'bridge';
  map[17][10] = 'bridge';

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const tile = document.createElement('div');
      const type = map[r][c];
      tile.className = `tile ${type}`;
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.dataset.terrain = type;
      tile.onclick = handleTileClick;
      container.appendChild(tile);
      grid.push({ row: r, col: c, terrain: type, unit: null, element: tile });
    }
  }
}

function updateTileDisplay(tileData) {
  const tile = tileData.element;
  tile.innerHTML = '';
  tile.classList.remove('france', 'russia', 'routed', 'selected', 'morale-break', 'attack-hit');

  if (tileData.unit) {
    const unit = tileData.unit;
    tile.classList.add(unit.faction);
    if (unit.routing) tile.classList.add('routed');

    // Add morale-break effect if routing
    if (unit.routing) tile.classList.add('morale-break');

    const label = document.createElement('div');
    label.className = 'unit-label';
    label.textContent = unit.routing ? 'R' : unit.type[0].toUpperCase();

    const hp = document.createElement('div');
    hp.className = 'hp-bar';
    hp.textContent = `${unit.hp} HP`;

    const morale = document.createElement('div');
    morale.className = 'morale-bar';
    morale.textContent = `Morale: ${unit.morale}`;

    tile.appendChild(label);
    tile.appendChild(hp);
    tile.appendChild(morale);
  }
}

function getCombatModifier(terrain) {
  if (terrain === 'forest') return 0.9;
  if (terrain === 'hill') return 1.1;
  if (terrain === 'river') return 0.8;
  return 1.0;
}

function handleTileClick(e) {
  const tile = e.currentTarget;
  const row = +tile.dataset.row;
  const col = +tile.dataset.col;
  const tileData = grid.find(t => t.row === row && t.col === col);

  if (deploymentPhase) {
    if ((currentFaction === 'france' && row >= 10) || (currentFaction === 'russia' && row < 10)) return;
    if (tileData.unit) return;

    const unit = {
      type: selectedUnitType,
      faction: currentFaction,
      hp: 100,
      morale: 100,
      hasMoved: false,
      hasAttacked: false,
      routing: false,
      routingTurns: 0
    };

    tileData.unit = unit;
    updateTileDisplay(tileData);
    playSound('moveSound');
    return;
  }

  if (!deploymentPhase) {
    if (selectedTile) {
      selectedTile.classList.remove('selected');
    }

    const tileUnit = tileData.unit;

    if (selectedTile === tile) {
      // Deselect if clicking same tile
      selectedTile = null;
      return;
    }

    if (!selectedTile) {
      // Select unit if it belongs to current faction and is not routed and can move
      if (tileUnit && tileUnit.faction === currentFaction && !tileUnit.routing && !tileUnit.hasMoved) {
        tile.classList.add('selected');
        selectedTile = tile;
      }
      return;
    }

    // If a unit is selected, try move or attack
    const fromRow = +selectedTile.dataset.row;
    const fromCol = +selectedTile.dataset.col;
    const fromTileData = grid.find(t => t.row === fromRow && t.col === fromCol);
    const fromUnit = fromTileData.unit;

    const dx = Math.abs(fromRow - row);
    const dy = Math.abs(fromCol - col);
    const isAdjacent = dx + dy === 1;

    if (isAdjacent && fromUnit && fromUnit.faction === currentFaction && !fromUnit.hasMoved && !fromUnit.routing) {
      if (!tileUnit) {
        // Move
        tileData.unit = fromUnit;
        tileData.unit.hasMoved = true;
        updateTileDisplay(tileData);
        fromTileData.unit = null;
        updateTileDisplay(fromTileData);
        playSound('moveSound');
      } else if (tileUnit.faction !== currentFaction && !fromUnit.hasAttacked) {
        // Attack
        const attackerMod = getCombatModifier(fromTileData.terrain);
        const damage = Math.floor(30 * attackerMod);
        tileUnit.hp -= damage;
        tileUnit.morale -= 25;
        fromUnit.hasAttacked = true;
        playSound('attackSound');

        // Flash attacked tile
        tile.classList.add('attack-hit');
        setTimeout(() => tile.classList.remove('attack-hit'), 500);

        if (tileUnit.morale <= 30 && !tileUnit.routing) {
          tileUnit.routing = true;
          tileUnit.routingTurns = 0;
          playSound('routingSound');
          tile.classList.add('morale-break');
        }
        if (tileUnit.hp <= 0 || tileUnit.morale <= 0) {
          tileData.unit = null;
          tile.classList.remove('morale-break');
        }
        updateTileDisplay(tileData);
      }
      selectedTile.classList.remove('selected');
      selectedTile = null;
    } else {
      selectedTile.classList.remove('selected');
      selectedTile = null;
    }
  }
}

// Helper: get tile neighbors (up, down, left, right)
function getNeighbors(tile) {
  const directions = [
    [-1, 0], [1, 0], [0, -1], [0, 1]
  ];
  const neighbors = [];
  for (const [dr, dc] of directions) {
    const nr = tile.row + dr;
    const nc = tile.col + dc;
    const neighbor = grid.find(t => t.row === nr && t.col === nc);
    if (neighbor) neighbors.push(neighbor);
  }
  return neighbors;
}

// Move routed unit one tile away from nearest enemy if possible
function moveRoutedUnit(tileData) {
  if (!tileData.unit || !tileData.unit.routing) return;
  const unit = tileData.unit;
  const neighbors = getNeighbors(tileData);

  // Tiles adjacent with no unit
  const emptyTiles = neighbors.filter(t => !t.unit);

  if (emptyTiles.length === 0) return;

  // Pick the tile which increases distance from enemies most
  function distToNearestEnemy(tile) {
    let minDist = Infinity;
    for (const t of grid) {
      if (t.unit && t.unit.faction !== unit.faction) {
        const dist = Math.abs(t.row - tile.row) + Math.abs(t.col - tile.col);
        if (dist < minDist) minDist = dist;
      }
    }
    return minDist;
  }

  emptyTiles.sort((a, b) => distToNearestEnemy(b) - distToNearestEnemy(a));

  const safestTile = emptyTiles[0];
  // Move unit to safest tile
  safestTile.unit = unit;
  tileData.unit = null;
  updateTileDisplay(safestTile);
  updateTileDisplay(tileData);
}

function endTurn() {
  selectedTile = null;

  // Gather all routed units belonging to current faction (unit objects)
  const routedUnits = grid
    .filter(t => t.unit && t.unit.faction === currentFaction && t.unit.routing)
    .map(t => t.unit);

  // Move each routed unit
  routedUnits.forEach(unit => {
    const tile = grid.find(t => t.unit === unit);
    if (tile) moveRoutedUnit(tile);
  });

  // Increment routingTurns & remove if > 3 turns on current tile
  routedUnits.forEach(unit => {
    const tile = grid.find(t => t.unit === unit);
    if (!tile) return;
    unit.routingTurns++;
    if (unit.routingTurns > 3) {
      tile.unit = null;
      updateTileDisplay(tile);
    }
  });

  // Reset move/attack status for current faction units & update display
  grid.forEach(t => {
    if (t.unit && t.unit.faction === currentFaction) {
      t.unit.hasMoved = false;
      t.unit.hasAttacked = false;
    }
    updateTileDisplay(t);
  });

  // Check win condition
  const franceUnits = grid.filter(t => t.unit && t.unit.faction === 'france').length;
  const russiaUnits = grid.filter(t => t.unit && t.unit.faction === 'russia').length;

  if (franceUnits === 0) {
    alert('Russia Wins!');
    resetGame();
    return;
  }
  if (russiaUnits === 0) {
    alert('France Wins!');
    resetGame();
    return;
  }

  // Switch turn
  currentFaction = currentFaction === 'france' ? 'russia' : 'france';
  document.getElementById('turnDisplay').textContent = `Turn: ${currentFaction.charAt(0).toUpperCase() + currentFaction.slice(1)}`;
}

function resetGame() {
  deploymentPhase = true;
  currentFaction = 'france';
  selectedTile = null;
  document.getElementById('startScreen').style.display = 'block';
  document.getElementById('turnDisplay').style.display = 'none';
  document.getElementById('endTurnBtn').style.display = 'none';
  document.getElementById('deployFaction').textContent = 'France';
  createBattlefield();
}

createBattlefield();
</script>

</body>
</html>